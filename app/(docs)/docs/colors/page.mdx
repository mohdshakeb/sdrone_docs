import SemanticColorTable from '@/components/docs/SemanticColorTable';

# Colors

Our design system uses a two-layered color approach: **Primitives** (atomic values) and **Semantics** (usage-based tokens).

<Section divider>

## Primitives

These are the raw values available in our palette.

### Primary (Orange)

<Preview layout="flex-wrap" padding="sm" gap="lg">
  {['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950', 'alpha-20'].map((step) => (
    <ColorSwatch
      key={step}
      token={`--color-primary-${step}`}
      name={step}
      showValue={false}
    />
  ))}
</Preview>

### Cool Gray (Neutrals)

<Preview layout="flex-wrap" padding="sm" gap="lg">
  {['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950'].map((step) => (
    <ColorSwatch
      key={step}
      token={`--color-cool-${step}`}
      name={step}
      showValue={false}
    />
  ))}
</Preview>

### Warm Gray (Neutrals)

<Preview layout="flex-wrap" padding="sm" gap="lg">
  {['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950'].map((step) => (
    <ColorSwatch
      key={step}
      token={`--color-warm-${step}`}
      name={step}
      showValue={false}
    />
  ))}
</Preview>

</Section>

<Section divider>

## Status Colors

These palettes are used for feedback states (badges, alerts, notifications).

### Blue (Information)

<Preview layout="flex-wrap" padding="sm" gap="lg">
  {['100', '600', '900'].map((step) => (
    <ColorSwatch
      key={step}
      token={`--color-blue-${step}`}
      name={step}
      showValue={false}
    />
  ))}
</Preview>

### Red (Negative)

<Preview layout="flex-wrap" padding="sm" gap="lg">
  {['100', '600', '900'].map((step) => (
    <ColorSwatch
      key={step}
      token={`--color-red-${step}`}
      name={step}
      showValue={false}
    />
  ))}
</Preview>

### Yellow (Notice)

<Preview layout="flex-wrap" padding="sm" gap="lg">
  {['100', '600', '900'].map((step) => (
    <ColorSwatch
      key={step}
      token={`--color-yellow-${step}`}
      name={step}
      showValue={false}
    />
  ))}
</Preview>

### Green (Positive)

<Preview layout="flex-wrap" padding="sm" gap="lg">
  {['100', '600', '900'].map((step) => (
    <ColorSwatch
      key={step}
      token={`--color-green-${step}`}
      name={step}
      showValue={false}
    />
  ))}
</Preview>

### Purple (Neutral Status)

<Preview layout="flex-wrap" padding="sm" gap="lg">
  {['100', '600', '900'].map((step) => (
    <ColorSwatch
      key={step}
      token={`--color-purple-${step}`}
      name={step}
      showValue={false}
    />
  ))}
</Preview>

</Section>

<Section divider>

## Semantic Tokens

Semantic tokens abstract the raw values to ensure consistency and themeability. The table below updates automatically based on your current theme (use the toggle in the header).

<Callout type="info" title="Theme Policy">
- **Light Mode**: Uses the **Warm Palette** (e.g., `fg-neutral` → `warm-900`).
- **Dark Mode**: Uses the **Cool Palette** (e.g., `fg-neutral` → `cool-50`).
</Callout>

<SemanticColorTable />

</Section>

<Section>

## Usage

<CodeBlock language="tsx" filename="example.tsx">
```tsx
// Always use semantic tokens in components
<div style={{
  backgroundColor: 'var(--bg-surface)',
  color: 'var(--fg-neutral)',
  border: '1px solid var(--border-subtle)'
}}>
  Content
</div>

// For status colors
<Badge color="positive">Success</Badge>
<Badge color="negative">Error</Badge>

// Primitive tokens should only be used in globals.css
// to define semantic tokens
```
</CodeBlock>

</Section>
